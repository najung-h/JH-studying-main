### 완전탐색 문제 1. 주사위 눈의 합

" 3개의 주사위를 던져 나올 수 있는 중복 순열에 대해, 합이 10 이하가 나오는 경우는 총 몇 가지 인가? "



- 먼저 합을 출력하는 코드를 작성
- 재귀호출을 할 때마다 선택한 값의 **누적 합**을 구함

- 파라미터에 sum을 추가하여 구현
  - sum : 지금까지 구한 합
  - i : 선택한 주사위 눈금
- 재귀호출 할 때 sum + i 값을 전달



```python
path = []

def kfc(x, sum):
    if x == 3:               # 종료 조건, 뽑은 횟수가 3이면 종료
        if sum <= 10:        # (백트래킹 코드가 없다면)실제로는 모두 탐색하지만, sum이 10 이하일 때만 출력
            print(f'{path} = {sum}')
        return

    for i in range(1, 7):    # 주사위 눈 1~6
        path.append(i)       # 경로에 추가
        kfc(x + 1, sum + i)  # 깊이를 하나 늘려서 재귀 호출
        path.pop()           # 원상복구

kfc(x=0, sum=0)
```



완전탐색 + 가지치기

답이 아닌 것에 대해서는 즉시 되돌아가자(누적합이 10 넘어가는 순간 더 탐색할 필요 없다)

```python
path = []
cnt = 0

def kfc(x, sum):
    global cnt
    if sum >10: # 종료 조건 1 # 백트래킹 # 이미 답이 될 수 없으면 그만 탐색하자.
        return 
    
    if x == 3:               # 종료 조건2 : 뽑은 횟수가 3이면 종료
        #if sum <= 10:        # (백트래킹 코드가 없다면)실제로는 모두 탐색하지만, sum이 10 이하일 때만 출력
        #    print(f'{path} = {sum}')
        cnt += 1
        return

    for i in range(1, 7):    # 주사위 눈 1~6
        path.append(i)       # 경로에 추가
        kfc(x + 1, sum + i)  # 깊이를 하나 늘려서 재귀 호출
        path.pop()           # 원상복구

kfc(x=0, sum=0)
print(cnt) # 108
```



---

### 완전탐색 문제 2. 연속 3장의 트럼프 카드

```python
card = ['A', 'J', 'Q', 'K']   # 사용할 카드 종류 (총 4가지)
path = []                     # 현재까지 뽑은 카드들을 저장하는 리스트
cnt = 0                       # 조건을 만족하는 경우의 수를 세는 변수



# 조건 확인 함수: 동일한 카드가 연속 3번 이상 나왔는지 검사
def cont_three():
    if path[0] == path[1] == path[2]: return True   # 첫 3장이 같으면 True
    if path[1] == path[2] == path[3]: return True   # 2~4번째가 같으면 True
    if path[2] == path[3] == path[4]: return True   # 3~5번째가 같으면 True
    return False                                    # 아니면 False



# 재귀적으로 카드 뽑기 (중복 순열)
def permu(lev):
    global cnt
    if lev == 5:                    # 카드 5장을 모두 뽑았다면
        if cont_three():            # 3장이 연속 같은지 검사
            cnt += 1                # 조건 만족 시 cnt 증가
        return                      # 종료

    for i in range(4):              # 카드 4종류 중 하나 선택
        path.append(card[i])        # 카드 추가
        permu(lev + 1)              # 다음 단계로 (깊이 증가)
        path.pop()                  # 원상복구 (백트래킹)

permu(0)                            # 시작: 0번째 단계부터 실행
print(cnt)                          # 조건 만족하는 경우의 수 출력

```







