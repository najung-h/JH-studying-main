# 복잡도 분석

---

#### **1. 알고리즘이란?**  

- 유한한 단계를 통해 **문제를 해결하기 위한 절차나 방법**  
  - 주로 컴퓨터용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말함  
- 간단하게 다시 말하면 어떠한 문제를 해결하기 위한 절차라고 볼 수 있음  
- 1부터 100까지의 합을 구하는 두 가지 알고리즘의 예  

  1. ​    1 + 2 + 3 + ... + 100 = 5,050  

  2. ​    (100 × (1 + 100)) ÷ 2 = 5,050  



#### **2. 알고리즘의 효율**  

- 공간적 효율성과 시간적 효율성  

  - **공간적 효율성**: 알고리즘이 필요로 하는 **메모리 공간**  
  - **시간적 효율성**: 알고리즘이 작업을 완료하는 데 걸리는 **시간**  
  - 효율성을 뒤집어 표현하면 복잡도(Complexity)가 됨  
    - 복잡도가 높을수록 효율성은 저하됨  

※ 시간적 효율성은 주로 **<u>입력 크기 n에 대한 연산 횟수</u>**로 나타냄  

​	-> 변수들에 대한 복잡도의 표기임에 주의



### 3. 복잡도의 점근적 표기법

- 시간 (또는 공간) 복잡도는 입력 크기에 대한 함수로 표기  
  - 이 함수는 주로 여러 개의 항을 가지는 **다항식**임  
  - 이를 **단순한 함수로 표현하기 위해** 점근적 표기 (Asymptotic Notation)를 사용  

  
  
- **입력 크기 n이 무한대로 커질 때**의 복잡도를 간단히 표현하기 위해 사용하는 표기법  
  
  - ***O(Big-Oh) 표기**             ->     최악의 상황
  - Ω(Big-Omega) 표기      ->     최선의 상황
  - Θ(Big-Theta) 표기         ->     평균

​	-> 1 <= N <= 100,000 일 때, 
​	   `O`는 100,000, `Ω`는 1, `Θ`는 평균을 기준으로 시간 복잡도를 계산
​	    

#### **4. 자주 사용하는 O-표기**  

- O(1) : 상수 시간 (Constant time)  
- O(log n) : 로그(대수) 시간 (Logarithmic time)  
- O(n) : 선형 시간 (Linear time)  
- O(n log n) : 로그 선형 시간 (Log-linear time)  
- O(n²) : 제곱 시간 (Quadratic time)  
- O(n³) : 세제곱 시간 (Cubic time)  



##### 	**만약 O(log N) 이라면?**  

- 만약 N이 10,000이고 O(log N)으로 짠 알고리즘이 있다면,  
  	몇 번 반복하는 프로그램이라고 추정해도 될까?  
  	→ 약 13.3번  
  - 컴퓨터 분야에서 log의 밑 수는 10이 아니라 **2**  
    - 2¹³ < 10,000 < 2¹⁴  
  

​		-> 계산기에서는 log10000 / log 2 해주면 된다.



##### (참고)

같은 코드가 PC 성능에 따라 걸리는 시간이 다르기 때문에
실제 걸리는 시간으로 알고리즘 성능을 체크하는 건 의미가 X

** 때문에 코딩테스트에서는 연산 횟수에 따른 대략적인 시간을 약속
-> C 언어 기준 1초 당 1억 번 연산 가능
-> Python은 C언어보다 느리다 
-> **Python은 1초 당 3,000만 번 정도 연산 가능**

(예) 59개 테스트케이스를 합쳐서 Python의 경우 3초
-> 한 테스트 케이스 당 170만 번 정도가 가능하구나!
-> 이중 for 문, 3중 for문 ,,.. 가능한지 아닌지 확인할 수 있음!

(참고2)

pypy vs python 3

-> pypy는 반복문 등의 연산이 빠르다.

-> python3의 경우, 메모리를 효율적으로 활용한다(대표적으로 stack / 재귀호출의 사례에서 )



(참고3)

메모리 관리할 때
append()는 최대한 가능하다면 사용을 피하는 것이 좋습니다.

정확하게는 시간 때문인데,
append가 진행된다면, 
메모리가 계속해서 2배로 늘어난다.

내 리스트가 계속 2배로 늘어나는데,
다른 변수가 들어있다고 가정하면,
현재 위치에서는 2배로 늘리지 못하는 상황이 발생할 수 있다

이 경우, 리스트가 2배 늘리는 것이 가능한 메모리로 이동합니다.
이 경우 복사가 발생해서, 예상치 못한 시간이 추가로 발생합니다.

개발자는 예상할 수 있는 시간이 좋습니다.

때문에, 가능한 한 사용을 피하는 것이 좋습니다.
저는, 몇 만 번 이상이면 append 안 쓰는 것 같아요.

그럼, append를 안 쓰려면 어떤 식으로 피해야하는가. 
미리 만들어놓으면 돼요.
기본 값을 통해서 100,000개 만들어놓고,
index를 이용해서 채우면 됩니다.

1) append() 사용  
```python
for i in range(100_000):
    li.append(input())
```

2. 미리 리스트 크기 할당 후 인덱스로 입력

```python
li = [0] * 100_000
idx = 0
for i in range(100_000):
    li[idx] = input()
    idx += 1
```