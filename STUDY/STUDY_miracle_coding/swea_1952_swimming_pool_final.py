import sys
sys.stdin = open('input_1952.txt', 'r')

# '''수영장 덕분에 DP를 공부하게 되었읍니다.

# dp 동적계획법을 사용하려면 두 가지 조건이 필요하다.
# 1. 겹치는 부분 문제
# 2. 최적 부분 구조
# 즉, 동일한 작은 문제들이 반복하여 나타나는 경우이며,
# 부분 문제의 최적 결과 값을 사용해 전체 문제의 최적 결과를 낼 수 있는 경우를 의미한다.

# 수영장 문제의 경우, 각 달에 아래 두 가지 선택지를 동일하게 고려하게 된다.
# 1. 1일권 vs 월권 중 어떠한 것이 더 싼가.
# 2. 최근 3개월을 3개월권 한 장으로 처리하는 게 이득인가 아닌가.

# 이렇게 매달의 선택지를 채워나가고,
# 최종적으로는 연간권과도 비교를 할 수 있다.

# 그리디로 풀이할 경우, 탐욕적인 선택 때문에
# 전역에서 보면 최적 배치가 풀릴 수 있는데,
# dp의 점화식 내에서는 위와 같은 문제가 자연스레 해결된다.

# 때문에, 수영장 문제는 DP 로 풀이하는 것이 바람직하다고 볼 수 있다.

# 추가적으로, 인덱스 사용에서는
# 0-11이 아니라, 인간처럼 1-12로 사용해야 헷갈림을 조금 줄일 수 있다.

# 때문에 DP = [0] * 13으로 선언하고 시작하자.
# '''

T = int(input())

for test_case in range(1, T+1):
    fee_lst = list(map(int, input().split()))
    plan_for_each_month_lst = list(map(int, input().split()))


    # dp[m]은 m월까지의 최소 비용이 된다.
    dp = [0] * 13
    
    # 점화식 채우기
    for i in range(1, 13):
        

        # 1. 1일권 vs 1달권
        # 1일권과 1달권 중에 더 싼 것 일단 배정한다.
        cost = min(plan_for_each_month_lst[i-1] * fee_lst[0] , fee_lst[1])

        # 누적합으로 접근하면 조금 더 이해가 된다.
        dp[i] = dp[i-1] + cost
            
            
        # 2. 1일/1달권 vs 3달권    
        # 3월 이후 부터는 3개월권을 고려한다. 
        # 3개월 권의 경우는 지난 3달을 커버한다.
        if i >=3 :
            # 지난 3달을 fee_3month로 퉁치는 게 싼지, 아니면
            # 지난 3달을 착실히 쌓아온 누적합으로 쓰는 게 싼지 계산한다.
            dp[i] = min(dp[i], dp[i-3] + fee_lst[2])
            
    
    # 마지막으로, 연간권을 비교한다.
    result = min(dp[12], fee_lst[3])


    print(f'#{test_case} {result}')
