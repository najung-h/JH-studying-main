# 문제 풀기 전 드래프트

<완전탐색>

A. 각각의 방향으로 이동하는 함수를 아래의 로직으로 생성한다.

1. 보드의 크기는 4 * 4
2. 한 번 이동해서 합쳐진 블록은 다시는 합쳐질 수 없다.
3. 위쪽으로 이동시킬 경우,
  1. 0행이 아닌 애들은 다 위로 이동한다.
  2. 각각의 애들에 대해 자신의 위를 확인했을 때
    1.  합쳐질 수 있는 애가 위에 있다면, 
        그리고, 인덱스리스트에 들어있지 않는다면
      1. 자신은 없애고
      2. 합쳐지는 애는  *= 2
      3. 그리고 합쳐진 애들은 그 인덱스를 합쳐짐_LST에 저장한다.
      

B. 이제는 5번 이동하는 4^5개만큼의 경우에 대해 결과를 시행하고, max값을 저장한다.
  그런데, 이 구현 방법을 잘 모르겠어서, 지피티한테 물어보았다.
  "이제는 5번 이동하는 5^5개만큼의 경우에 대해 결과를 시행하고, max값을 저장한다."라고 물었는데
  "👉 혹시 지금 하고 계신 게 BOJ 12100 (2048 Easy) 문제 맞나요?
맞다면 제가 move(board, dir) 함수까지 구현 예시를 붙여드릴 수도 있어요. 원하시나요?"라고 지피티가 문제 번호까지 맞춘다. 소름.
이 문제를 풀기위해서는 dfs를 학습해야하는 것 같아서, 그것을 먼저 학습해보았다.

  

