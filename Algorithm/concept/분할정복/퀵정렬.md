## 퀵 정렬 (Quick Sort)



#### 정의

기준값을 중심으로 주어진 배열을 두 개로 분할하고,
각각을 정렬하여 전체 배열을 정렬하는 방식



#### 병합 정렬과 퀵 정렬의 차이

| 구분      | 병합 정렬                               | 퀵 정렬                                                      |
| --------- | --------------------------------------- | ------------------------------------------------------------ |
| 분할 기준 | 단순히 배열을 반으로 나눔               | 기준 아이템(pivot item)을 중심으로, <br />기준보다 작은 것은 왼편, <br />큰 것은 오른편에 위치시킴 |
| 병합 처리 | 정렬된 부분을 다시 병합하는 과정이 필요 | 별도의 병합 과정 불필요                                      |



#### 시간 복잡도

- 평균 시간복잡도 O(nlogn)

- partitioning이라는 과정을 반복하면서,
  빠른 속도로 정렬이 된다!!



#### Partitioning

1. 작업 영역을 정한다.

2. 작업 영역 중 가장 왼쪽에 있는 수를 pivot이라고 하자.
   (Pivot을 "기준"으로 해석한다.)

   ** Pivot은 중간값, 우측 끝 값으로 설정해도 상관없지만, 
   우리는 왼쪽 끝 값을 기준으로 한다.

3. pivot을 기준으로

   - 왼쪽에는 Pivot보다 작은 수를 배치한다(정렬 안됨)
   - 오른쪽에는 Pivot보다 큰 수를 배치한다(정렬 안됨)

```mermaid
flowchart LR
    subgraph L["Pivot보다 작은 수들 (정렬 안 됨)"]
        A1[작은 값]
        A2[작은 값]
        A3[작은 값]
    end

    P[Pivot]

    subgraph R["Pivot보다 큰 수들 (정렬 안 됨)"]
        B1[큰 값]
        B2[큰 값]
        B3[큰 값]
    end

    L --> P --> R

```



전체 과정을 미리 한 번 보면...

```mermaid
sequenceDiagram
    participant A as [10, 69, 30, 2, 16, 8, 31, 22]

    Note over A: 처음 배열

    A->>A: Pivot = 22 선택
    Note over A: [10, 2, 16, 8] | 22 | [69, 30, 31]

    A->>A: 왼쪽 그룹 [10, 2, 16, 8] 분할<br/>Pivot = 8 선택
    Note over A: [2] | 8 | [10, 16]

    A->>A: 오른쪽 그룹 [69, 30, 31] 분할<br/>Pivot = 31 선택
    Note over A: [30] | 31 | [69]

    A->>A: [10, 16] 분할<br/>Pivot = 16 선택
    Note over A: [10] | 16 | []

    Note over A: 모든 부분배열이 크기 1이 되어 정렬 완료

```

참고로,

- 각 파티셔닝이 끝나고 Pivot의 위치는 확정됩니다.
- 즉, 정렬이 다 되었을 때도 Pivot의 위치는 지금 위치 그대로 배정됩니다.



전체 배열을 정렬하기 위해서는, 파티셔닝이 반복적으로 이루어지는데요.

- 한 번의 파티셔닝 이후, 왼쪽과 오른쪽 부분 배열에 대해 재귀적으로 파티셔닝을 반복하여 정렬을 진행합니다.
  1. 작업 영역 지정
  2. Pivot 결정
  3. Pivot을 기준으로 배치 변경
  4. 파티셔닝의 마무리에서 해당 Pivot의 위치는 fix



#### Lomuto 파티션

```mermaid
flowchart LR
    subgraph R["Hoare Partition (첫 원소 Pivot)"]
        R0["배열: [10, 69, 30, 2, 16, 8, 31, 22]"]
        R1["Pivot = 10 (첫 원소)"]
        R2["왼쪽 포인터 → 오른쪽 이동"]
        R3["오른쪽 포인터 ← 왼쪽 이동"]
        R4["잘못된 원소 만나면 swap"]
        R5["포인터 교차 시 중단"]
        R6["결과: [2, 8] | 10 | [69, 30, 16, 31, 22]"]

        R0 --> R1 --> R2 --> R3 --> R4 --> R5 --> R6
    end

    subgraph L["Lomuto Partition (마지막 원소 Pivot)"]
        L0["배열: [10, 69, 30, 2, 16, 8, 31, 22]"]
        L1["Pivot = 22 (마지막 원소)"]
        L2["i = -1, j를 왼→오로 스캔"]
        L3["작은 값 발견 시 swap → 왼쪽 모음"]
        L4["pivot(22) ↔ arr[i+1] 교환"]
        L5["결과: [10, 2, 16, 8] | 22 | [69, 30, 31]"]

        L0 --> L1 --> L2 --> L3 --> L4 --> L5
    end


```



```mermaid
flowchart TB
    subgraph L["Lomuto Partition (마지막 원소 Pivot)"]
        L0["배열: [10, 69, 30, 2, 16, 8, 31, 22]"]
        L1["Pivot = 22 (마지막 원소)"]
        L2["i = low-1 = -1, j를 왼→오로 스캔"]
        L3["작은 값 발견 시 swap → 왼쪽 모음"]
        L4["pivot(22) ↔ arr[i+1] 교환"]
        L5["결과: [10, 2, 16, 8] | 22 | [69, 30, 31]"]

        L0 --> L1 --> L2 --> L3 --> L4 --> L5
    end


```

```mermaid
flowchart TB

    subgraph R["Hoare Partition (첫 원소 Pivot)"]
        R0["배열: [10, 69, 30, 2, 16, 8, 31, 22]"]
        R1["Pivot = 10 (첫 원소)"]
        R2["왼쪽 포인터 → 오른쪽 이동"]
        R3["오른쪽 포인터 ← 왼쪽 이동"]
        R4["잘못된 원소 만나면 swap"]
        R5["포인터 교차 시 중단"]
        R6["결과: [2, 8] | 10 | [69, 30, 16, 31, 22]"]

        R0 --> R1 --> R2 --> R3 --> R4 --> R5 --> R6
    end

```



```mermaid
sequenceDiagram
    participant Lomuto as Lomuto (pivot = last, 22)
    participant Hoare as Hoare (pivot = first, 10)

    %% --- Lomuto partition steps ---
    Note over Lomuto: 초기: [10, 69, 30, 2, 16, 8, 31, 22]
    Lomuto->>Lomuto: j=0, 10 ≤ 22 → i=0, swap(0,0)
    Note over Lomuto: [10, 69, 30, 2, 16, 8, 31, 22]
    Lomuto->>Lomuto: j=1, 69 > 22 → pass
    Note over Lomuto: [10, 69, 30, 2, 16, 8, 31, 22]
    Lomuto->>Lomuto: j=2, 30 > 22 → pass
    Note over Lomuto: [10, 69, 30, 2, 16, 8, 31, 22]
    Lomuto->>Lomuto: j=3, 2 ≤ 22 → i=1, swap(1,3)
    Note over Lomuto: [10, 2, 30, 69, 16, 8, 31, 22]
    Lomuto->>Lomuto: j=4, 16 ≤ 22 → i=2, swap(2,4)
    Note over Lomuto: [10, 2, 16, 69, 30, 8, 31, 22]
    Lomuto->>Lomuto: j=5, 8 ≤ 22 → i=3, swap(3,5)
    Note over Lomuto: [10, 2, 16, 8, 30, 69, 31, 22]
    Lomuto->>Lomuto: j=6, 31 > 22 → pass
    Lomuto->>Lomuto: 종료 → swap(i+1=4, high=7)
    Note over Lomuto: 파티션 결과: [10, 2, 16, 8, 22, 69, 31, 30] (pivot index = 4)

    %% --- Hoare partition steps ---
    Note over Hoare: 초기: [10, 69, 30, 2, 16, 8, 31, 22]
    Hoare->>Hoare: pivot = 10, left=-1, right=8
    Hoare->>Hoare: left→0(10), right→5(8) → swap(0,5)
    Note over Hoare: [8, 69, 30, 2, 16, 10, 31, 22]
    Hoare->>Hoare: left→1(69), right→3(2) → swap(1,3)
    Note over Hoare: [8, 2, 30, 69, 16, 10, 31, 22]
    Hoare->>Hoare: left→2(30), right→2(30) → left≥right ⇒ stop
    Note over Hoare: 파티션 경계: index=1 (≤pivot: [8,2] | 나머지 오른쪽)<br/>※ Hoare는 이 단계에서 pivot(10)을 제자리로 옮기지 않음

```







#### 코드

1. Lomuto Partition - 주로 마지막 원소를 피벗으로

   재귀 호출을 관리하는 `quick_sort` 함수와, 실제 분할을 담당하는 `partition` 함수로 나누어 구현

   ```python
   def partition(arr, start, end):
       """
       분할(Partition)을 담당하는 실무자 함수.
       - 가장 오른쪽 원소(arr[end])를 피벗으로 설정.
       - 피벗보다 작은 값들은 왼쪽으로, 큰 값들은 오른쪽으로 재배치.
       - 최종적으로 피벗이 있어야 할 올바른 위치의 인덱스를 반환.
       """
       # 피벗을 가장 오른쪽 원소로 설정
       pivot = arr[end]
       # 피벗보다 작은 원소들을 저장할 경계 인덱스 i
       i = start - 1
   
       # start부터 end-1까지 순회
       for j in range(start, end):
           # 현재 원소가 피벗보다 작으면,
           if arr[j] < pivot:
               # 작은 원소 그룹의 경계를 한 칸 오른쪽으로 이동
               i += 1
               # 경계(i)와 현재 원소(j)의 위치를 교환하여, 작은 원소를 왼쪽으로 보냄
               arr[i], arr[j] = arr[j], arr[i]
   
       # 모든 순회가 끝나면, i+1 위치가 피벗이 들어갈 자리.
       # 피벗(arr[end])과 경계 다음 위치(arr[i+1])의 값을 교환
       arr[i + 1], arr[end] = arr[end], arr[i + 1]
   
       # 피벗의 최종 위치 인덱스를 반환
       return i + 1
   
   
   def quick_sort(arr, start, end):
       """
       퀵 정렬을 재귀적으로 지시하는 '매니저' 함수.
       """
       # 기저 조건: 정렬할 범위에 원소가 1개 이하일 때 (start >= end)
       if start < end:
           # 1. 분할: partition 함수를 호출하여 피벗의 최종 위치를 찾음
           pivot_idx = partition(arr, start, end)
   
           # 2. 정복 (재귀 호출)
           # 피벗을 기준으로 나뉜 왼쪽 부분을 재귀적으로 정렬
           quick_sort(arr, start, pivot_idx - 1)
           # 피벗을 기준으로 나뉜 오른쪽 부분을 재귀적으로 정렬
           quick_sort(arr, pivot_idx + 1, end)
   
   
   # --- 실행 코드 ---
   data_list = [3, 2, 4, 6, 9, 1, 8, 7, 5]
   print(f"정렬 전: {data_list}")
   
   quick_sort(data_list, 0, len(data_list) - 1)
   print(f"정렬 후: {data_list}")
   
   ```

   출력

   ```txt
   정렬 전: [3, 2, 4, 6, 9, 1, 8, 7, 5]
   정렬 후: [1, 2, 3, 4, 5, 6, 7, 8, 9]
   ```

   

2. Hoare-Partitioning - 주로 첫 번째 원소를 마지막으로

   ```python
   def partition_hoare(arr, start, end):
       """
       Hoare 파티션 방식
       - arr[start]를 피벗으로 사용
       - left, right 포인터가 교차할 때까지 값을 교환
       """
       pivot = arr[start]
       left = start + 1
       right = end
   
       while True:
           # left 포인터 이동: 피벗보다 큰 값을 찾을 때까지
           while left <= end and arr[left] < pivot:
               left += 1
   
           # right 포인터 이동: 피벗보다 작은 값을 찾을 때까지
           while left <= right and arr[right] > pivot:
               right -= 1
   
           # 포인터가 교차했다면 반복 종료
           if left > right:
               break
   
           # 교차 전이면 두 값의 위치를 교환
           arr[left], arr[right] = arr[right], arr[left]
   
       # 마지막으로 피벗과 right 포인터가 가리키는 값을 교환
       arr[start], arr[right] = arr[right], arr[start]
   
       # 피벗의 최종 위치인 right를 반환
       return right
   
   
   def quick_sort_hoare(arr, start, end):
       if start < end:
           pivot_idx = partition_hoare(arr, start, end)
   
           # Hoare 파티션은 피벗의 왼쪽/오른쪽을 모두 포함하여 재귀 호출
           # (피벗이 최종 위치에 있다는 보장이 없기 때문)
           quick_sort_hoare(arr, start, pivot_idx - 1)
           quick_sort_hoare(arr, pivot_idx + 1, end)
   
   
   # --- 실행 코드 ---
   data_list = [3, 2, 4, 6, 9, 1, 8, 7, 5]
   print(f"정렬 전: {data_list}")
   
   quick_sort_hoare(data_list, 0, len(data_list) - 1)
   print(f"정렬 후: {data_list}")
   
   ```

   출력

   ```txt
   정렬 전: [3, 2, 4, 6, 9, 1, 8, 7, 5]
   정렬 후: [1, 2, 3, 4, 5, 6, 7, 8, 9]
   ```

   