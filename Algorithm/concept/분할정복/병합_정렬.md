## 병합 정렬 (Merge Sort)



#### 정의

- 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식
- 일단 잘게 쪼갠 뒤, 작은 단위부터 정렬하여 합쳐나가는 방식이다.



(참고) 분할 정복 기법을 사용하는 대표적인 정렬 알고리즘이다.



#### 과정

- 자료를 최소 단위의 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻어냄
- top-down 방식



#### 시간 복잡도

`O(N log N)`

- 데이터를 나누는 과정이 O(log N)
- 데이터를 한번씩 비교하면서 병합하는 과정이 O(N)



#### 공간 복잡도

O(N)

- 병합 과정에서 정렬된 결과를 담을 추가적인 배열 필요



#### 안정 정렬 이다!

- 값이 같은 원소들의 상대적인 순서가 정렬 후에도 유지된다.



#### 병합 정렬 과정 예시

{69, 10, 30, 2, 16, 8, 31, 22}를 병합 정렬하는 과정

- 분할 단계 : 전체 자료 집합에 대하여, 최소 크기의 부분집합(원소 1개)이 될 때까지 분할 작업을 계속한다.

  ```mermaid
  flowchart TB
    A["69 | 10 | 30 | 2 | 16 | 8 | 31 | 22"]
    A --> B1["69  10  30  2"]
    A --> B2["16  8  31  22"]
  
    B1 --> C1["69  10"]
    B1 --> C2["30  2"]
    C1 --> D1["69"]
    C1 --> D2["10"]
    C2 --> D3["30"]
    C2 --> D4["2"]
  
    B2 --> C3["16  8"]
    B2 --> C4["31  22"]
    C3 --> D5["16"]
    C3 --> D6["8"]
    C4 --> D7["31"]
    C4 --> D8["22"]
  
  ```

  

- 병합 단계 : 2개의 부분집합을 정렬하면서 하나의 집합으로 병합한다. 8개의 부분집합이 1개로 병합될 때까지 반복

  ```mermaid
  flowchart TB
    subgraph L["왼쪽 절반"]
      LA["69"] --> Lp1["(정렬) 10 69"]
      LB["10"] --> Lp1
      LC["30"] --> Lp2["(정렬) 2 30"]
      LD["2"]  --> Lp2
      Lp1 --> Lp3["(정렬) 2 10 30 69"]
      Lp2 --> Lp3
    end
  
    subgraph R["오른쪽 절반"]
      RA["16"] --> Rp1["(정렬) 8 16"]
      RB["8"]  --> Rp1
      RC["31"] --> Rp2["(정렬) 22 31"]
      RD["22"] --> Rp2
      Rp1 --> Rp3["(정렬) 8 16 22 31"]
      Rp2 --> Rp3
    end
  
    Lp3 --> FIN["최종 정렬: 2 8 10 16 22 30 31 69"]
    Rp3 --> FIN
  
  ```





#### 병합 정렬 코드

병합 정렬은 보통 두 개의 함수로 역할을 나누어 구현한다.
`merge_sort(arr)` : 분할과 재귀 호출을 담당하는 함수

`merge(left, right)`: 정렬된 두 배열을 합치는 함수

1. 분할 과정

   ```python
   def merge_sort(arr):
       """
       병합 정렬을 재귀적으로 구현하는 '매니저' 함수.
       """
       # 기저 조건(Base Case): 배열의 길이가 1 이하면 이미 정렬된 상태이므로 그대로 반환
       if len(arr) <= 1:
           return arr
   
       # 1. 분할 (Divide): 배열을 절반으로 나눔
       mid = len(arr) // 2
       left_half = arr[:mid]
       right_half = arr[mid:]
   
       # 2. 정복 (Conquer): 각 절반을 재귀적으로 정렬
       # left_half와 right_half는 결국 정렬된 상태로 반환됨
       left_sorted = merge_sort(left_half)
       right_sorted = merge_sort(right_half)
   
       # 3. 통합 (Combine): 정렬된 두 부분을 병합하여 반환
       return merge(left_sorted, right_sorted)
   ```

2. 병합 과정

   ```python
   def merge(left_arr, right_arr):
       """
       이미 정렬된 두 배열(left_arr, right_arr)을
       하나의 정렬된 배열로 '병합'하는 함수.
       """
       merged_arr = []
       # 두 배열을 가리킬 포인터(인덱스) 초기화
       left_idx, right_idx = 0, 0
   
       # 두 배열 중 하나라도 원소가 남아있는 동안 반복
       while left_idx < len(left_arr) and right_idx < len(right_arr):
           # 왼쪽 배열의 값이 더 작거나 같으면, 결과에 추가하고 왼쪽 포인터 이동
           if left_arr[left_idx] <= right_arr[right_idx]:
               merged_arr.append(left_arr[left_idx])
               left_idx += 1
           # 오른쪽 배열의 값이 더 작으면, 결과에 추가하고 오른쪽 포인터 이동
           else:
               merged_arr.append(right_arr[right_idx])
               right_idx += 1
   
       # 위 루프가 끝난 후, 아직 남아있는 원소들을 결과 뒤에 그대로 붙여줌
       # (한쪽 배열은 이미 모든 원소가 소진되었으므로, 둘 중 하나만 실행됨)
       merged_arr.extend(left_arr[left_idx:])
       merged_arr.extend(right_arr[right_idx:])
   
       return merged_arr
   ```

3. 메인

   ```python
   # --- 실행 코드 ---
   data_array = [69, 10, 30, 2, 16, 8, 31, 22]
   print(f"정렬 전: {data_array}")
   
   sorted_array = merge_sort(data_array)
   print(f"정렬 후: {sorted_array}")
   ```

4. 결과

   ```txt
   정렬 전: [69, 10, 30, 2, 16, 8, 31, 22]
   정렬 후: [2, 8, 10, 16, 22, 30, 31, 69]





#### 참고) 반복문을 이용한 병합 정렬

Bottom-UP 방식으로 재귀 없이 반복문으로도 구현할 수 있다.

다만, 이는 분할 정복의 철학을 반영하지는 않는다!!!는 점을 주의



##### 과정

1. 먼저 배열을 길이 1짜리 정렬된 부분 배열 여러 개로 본다
2. 길이 1짜리들을 두 개씩 짝지어, 정렬된 길이 2짜리 부분 배열들로 만든다
3. 다시 길이 2짜리들을 두 개씩 짝지어 정렬된 길이 4짜리 부분 배열들로 만든다
4. 이 과정을 부분 배열의 크기가 전체 배열의 크기가 될때까지 반복한다.



##### 코드

```python
def merge_two_subarrays(arr, start, mid, end):
    """
    arr[start..mid]와 arr[mid+1..end]라는 두 정렬된 부분 배열을
    하나로 정렬해 병합하는 함수.
    """
    merged = []
    left_idx = start
    right_idx = mid + 1

    while left_idx <= mid and right_idx <= end:
        if arr[left_idx] <= arr[right_idx]:
            merged.append(arr[left_idx])
            left_idx += 1
        else:
            merged.append(arr[right_idx])
            right_idx += 1

    # 남은 요소 붙이기
    while left_idx <= mid:
        merged.append(arr[left_idx])
        left_idx += 1

    while right_idx <= end:
        merged.append(arr[right_idx])
        right_idx += 1

    # 실제 arr에 병합 결과 반영
    for i, val in enumerate(merged):
        arr[start + i] = val


def iterative_merge_sort(arr):
    """
    반복문(비재귀)으로 병합 정렬을 구현한 함수.
    Bottom-Up 방식:
    1) 길이 1씩 구간을 2개씩 합쳐 길이2 정렬
    2) 길이2씩 구간을 2개씩 합쳐 길이4 정렬
    3) ...
    """
    n = len(arr)
    size = 1  # 부분 배열의 크기(1,2,4,8,..)

    while size < n:
        # step 단위로 subarray를 병합
        for start in range(0, n, 2 * size):
            mid = start + size - 1
            end = min(start + 2 * size - 1, n - 1)

            # 만약 mid(왼쪽 구간 끝)가 배열 범위 내라면 병합 수행
            if mid < end < n:
                merge_two_subarrays(arr, start, mid, end)

        size *= 2


# ---- 실행 예시 ----
data_array = [69, 10, 30, 2, 16, 8, 31, 22]
print("정렬 전:", data_array)
iterative_merge_sort(data_array)
print("정렬 후:", data_array)

"""
정렬 전: [69, 10, 30, 2, 16, 8, 31, 22]
정렬 후: [2, 8, 10, 16, 22, 30, 31, 69]
"""

```















