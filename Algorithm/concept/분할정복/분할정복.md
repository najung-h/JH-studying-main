## 분할정복 (Divide and Conquer)



#### 정의

문제를 작은 하위 문제로 나누고(분할)
각각을 해결한 뒤(정복)
그 결과를 통합하여 원래 문제를 해결하는(통합)
알고리즘 기법으로

나폴레옹이 대표주자



(참고) 대표적인 문제 해결 기법 비교

| 기법                 | 설명                                               | 특징/주의점                                                  | 예시                                       | 시간복잡도                                    |
| -------------------- | -------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------ | --------------------------------------------- |
| 완전 탐색            | 모든 경우를 나열하고 테스트                        | 구현이 쉽고 확실한 정답 도출<br>경우의 수가 크면 **시간 초과 위험** | 순열/조합 탐색, 백트래킹 기초              | 보통 O(n!), O(2^n)                            |
| 탐욕 (Greedy)        | 매 순간 **최적**이라 생각되는 해를 선택            | 전역적 최적해 보장 X                                         | 최소 신장 트리(Kruskal, Prim), 허프만 코딩 | O(n log n) ~ O(E log V)<br /> *(E간선,V정점)* |
| 분할 정복            | 문제를 더 작은 **하위 문제**로 나누어 해결 후 결합 | 효율적, 병합 정렬·퀵 정렬 등에서 활용                        | 병합 정렬, 퀵 정렬, 이진 탐색              | 보통 O(n log n)                               |
| 동적 프로그래밍 (DP) | 부분 문제의 결과를 **메모**하여 중복 계산 방지     | 최적화 문제에 자주 사용                                      | 피보나치 수열, 최단 경로                   | 보통 O(n^2), O(n^3)                           |



#### 설계 전략

- 분할 : 해결할 문제를 여러 개의 작은 부분으로 나눔
- 정복 : 나눈 작은 문제를 각각 해결
  - 하위문제가 여전히 크다면, 분할을 재귀적으로 반복
- 통합 : (필요하다면) 해결된 해답을 모음



#### 분할 정복 기법의 구조

- Top-down approach 예시

  ```mermaid
  graph TD
      A[문제의 크기 n]
      A --> B1[크기 n/2인<br>부분 문제 1]
      A --> B2[크기 n/2인<br>부분 문제 2]
  
      B1 --> C1[부분 문제 1의 해]
      B2 --> C2[부분 문제 2의 해]
  
      C1 --> D[전체 문제의 해]
      C2 --> D
  
      subgraph 설명
          direction LR
          분할 --- 정복 --- 결합
      end
  
  ```





### 대표 알고리즘

1. 병합 정렬
   - 외부 정렬의 기본이 되는 정렬 알고리즘
   - 멀티코어 CPU나 다수의 프로세서에서 정렬 알고리즘을 병렬화하기 위해 병합 정렬 알고리즘이 활용되낟.
2. 퀵 정렬
   - 매우 큰 입력 데이터에 대해서 좋은 성능을 보이는 알고리즘
3. 이진 검색
   - 정렬된 데이터를 기준으로 특정 값이나 범위를 검색하는 데 사용
   - [이진검색을 활용한 심화학습 키워드] Lower Bound, Upper Bound
     - 정렬된 배열에서 특정 값 이상(이하) 가 처음으로 나타나는 위치를 찾는 알고리즘
     - 특정 데이터의 범위 검색 등에서 활용



### 장단점

- 장점
  - 논리적 해결 : 복잡하고 큰 문제를 논리적으로 명확한 작은 단위로 나누어 접근 가능하다
  - 효율성 : 시간 복잡도 (n^2 -> nlogn) 개선 가능
  - 병렬 처리 : 나누어진 하위 문제들은 서로 독립적이므로, 여러 개의 프로세서(cpu)를 사용한 병렬 처리에 유리
- 단점
  - 재귀 함수 사용 : 탐색 깊이가 깊어지면 stack overflow
  - 구현 복잡성 : '통합' 과정 구현이 어렵다



### 예시

1. 가짜 동전 찾기

   ```mark
   n개의 동전들 중에 가짜 동전이 하나 포함되어 있다. 가짜 동전은 진짜 동전에 비해 아주 조금 가볍다.
   진짜 동전들의 무게가 동일하다고 할 때 양팔 저울을 이용해서 가짜 동전을 찾아보자
   
   - 양팔 저울을 최소로 사용해서 가짜 동전을 찾는 방법은 무엇인가?
   - 예를 들어 동전이 24(진짜 23개, 가짜 1개) 있다면?

2. 거듭 제곱

   ```markdown
   자연수 C의 제곱 값은?
   ```

   - 기존에는?

     - 시간 복잡도 O(n)

     ```math
     C^2
     =C×C
     
     
     ```

     ```math
     𝐶^3
     =
     𝐶
     ×
     𝐶
     ×
     𝐶
     
     
     ```

     ```math
     𝐶^𝑛
     =
     𝐶
     ×
     𝐶
     ×
     𝐶
     ×
     ⋯
     ×
     𝐶
     
     ```

     ```python
     def iterative_power(x, n):
         result = 1
         for i in range(1, n + 1):  # 1부터 n까지 반복
             result *= x            # result = result * x
         return result
     
     # 실행 예시
     print(iterative_power(2, 5))  # 2^5 = 32
     print(iterative_power(3, 4))  # 3^4 = 81
     ```

   - 분할 정복 기반 거듭게곱을 한다면?

     - 시간복잡도 O(log_2 n)

     - 핵심 아이디어:

       - 짝수 지수는 

         ```math
         C^n = (C^{n/2})^2
         ```

         

       - 홀수 지수는

         ```math
         C^n = (C^{(n-1)/2})^2 \times C
         ```

       - 즉, 예를 들면

         ```math
         C8=C4×C4=(C4)2=((C2)2)2
         ```

         ```python
         def recursive_power(x, n):
             # 종료 조건
             if n == 1:
                 return x
             
             # 짝수일 경우
             if n % 2 == 0:
                 y = recursive_power(x, n // 2)
                 return y * y
             # 홀수일 경우
             else:
                 y = recursive_power(x, (n - 1) // 2)
                 return y * y * x
         
         # 실행 예시
         print(recursive_power(2, 8))  # 2^8 = 256
         print(recursive_power(3, 5))  # 3^5 = 243

























