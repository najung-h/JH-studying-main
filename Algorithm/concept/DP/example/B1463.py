# 백준 1463번 "1로 만들기"
# 링크 : https://www.acmicpc.net/problem/1463

# 문제 설명:
'''정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.

X가 3으로 나누어 떨어지면, 3으로 나눈다.
X가 2로 나누어 떨어지면, 2로 나눈다.
1을 뺀다.

정수 N이 주어졌을 때, 
위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 

연산을 사용하는 횟수의 최솟값을 출력하시오.'''

N = int(input())  # 1 <= N <= 1,000,000

# 짝수
    # 3의 배수
    # 3의 배수 + 1
    # 3의 배수 +2
    
# 홀수 # 2의 배수 +1
    # 3의 배수
    # 3의 배수 +1
    # 3의 배수 +2


# 어떤 숫자가 주어졌을 때
# 홀수면서 3의 배수가 아니라면, 무조건 1을 빼야한다.
# 홀수면서 3의 배수라면 3을 나누거나 (1을 빼거나)
# 짝수면서 3의 배수라면 2를 나누거나, 3을 나누거나, (1을 빼거나)
# 짝수면서 3의 배수 +1 이라면, 1을 빼거나, 2를 나누거나 <- 요기가 핵심
# 짝수면서 3의 배수 +2라면, 2를 나누거나 (1을 빼거나)


# DP를 사용할 것이기 때문에
# 일단 자료를 하나 새로 쓸게요

# 이 자료에서는 기억을 하면서 하나씩 업데이트 해야함

'''
시도 1
-> gpt한테 까임

dp = [N]

while True:
    num = dp[-1]
    
    
    if num % 2 == 1: # 홀수라면
        if num % 3 == 0 : # 3의 배수라면
            # 1을 빼거나 3을 나누거나
            candidate = min(num-1, num//3)
        else:
            candidate = num-1

    else: # 짝수라면
        if num % 3 == 0:
            candidate = min(num-1, num//2, num//3)
        
        elif num % 3 == 1:
            candidate = min(num//2, num-1)
            
        else:
            candidate = min(num//2, num-1)
        
    if candidate == 1:
        break
            
    dp.append(candidate)

print(len(dp))'''



'''gpt의 조언'''
# dp[i] = 숫자 i를 1로 만드는 최소 횟수

# dp[1] = 0 -> 이미 1이니까 연산이 필요 없어요.

# 그다음부터는 차례대로:

# dp[2] = dp[1]+1 (2->1)

# dp[3] = min(dp[2]+1, dp[1]+1)

# (3->2->1) = 2번

# (3->1) = 1번 -> 더 작은 거 고르기

# dp[4] = min(dp[3]+1, dp[2]+1)

# (4->3->1) = 2번

# (4->2->1) = 2번

# 이런 식으로 2부터 N까지 쭉 채워 넣는 거예요.


# 그래서,,,

# dp[i] = min( dp[i-1]+1, dp[i//2]+1 (i%2==0), dp[i//3]+1 (i%3==0) )

# i-1에서 올 수 있음 -> 한 번 더 빼기

# i//2에서 올 수 있음 -> 한 번 더 나누기

# i//3에서 올 수 있음 -> 한 번 더 나누기
# -> 이 셋 중에 가장 작은 값을 고르면 최적이에요.


dp = [0] * (N + 1)
dp[1] = 0  # 1은 이미 1이라 연산 필요 없음

for i in range(2, N + 1):
    dp[i] = dp[i-1] + 1  # 기본: 1 빼기
    if i % 2 == 0:
        dp[i] = min(dp[i], dp[i//2] + 1)
    if i % 3 == 0:
        dp[i] = min(dp[i], dp[i//3] + 1)

print(dp[N])


