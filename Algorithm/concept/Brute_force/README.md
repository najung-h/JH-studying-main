# 완전 탐색(Brute Force)



​	완전탐색은 

​	가능한 모든 경우를 생성하여 검사하는 가장 기본적인 탐색 방법입니다.

​	구현 난이도가 비교적 낮고, 항상 해답을 찾는 것이 가능하다는 장점을 가집니다.



​	이런 장점을 가졌으니, 당연히 단점도 있겠죠.

​	바로, 성능이 경우의 수에 비례해 폭증한다는 것입니다.



​	때문에 실전 문제 풀이 시에는,

1) 완전 탐색을 우선 구현하여 정답을 찾고
2) 이후 **탐욕법(그리디)**, **동적 계획법(DP)** 등으로 **성능을 최적화**

​	하는 접근을 많이 사용합니다.



---



​	이런 완전 탐색은

​	조합적 문제 : `순열` `조합` `부분집합`  와 엮입니다



​	완전 탐색 자체가 가능한 모든 경우의 수를 생성한 후에 검사하는 방식이기 때문에,

​	경우의 수를 모두 생성하는 과정에서

​	필연적으로 조합적 문제와 연결될 수밖에 없겠죠.



​	각각 한 번 볼게요.

​	`순열` 은 아래와 같은 경우에서 필요합니다.

```markdown
- 출발, 도착 도시를 선택하면 모든 도시를 여행하는 코스를 알려드립니다.
- 모든 도시를 여행하는 코스를 정할 때 어떤 코스 경비가 가장 적게 들까?
```



​	`조합`은 아래와 같은 경우에서 필요합니다.

```markdown
- 3개의 도시를 선택하면 숙박비를 지원해드립니다.
- 여행자는 어느 도시를 선택했을때 가장 이득일까?
```



​	`부분집합`은 아래와 같은 경우에서 필요합니다.

```markdown
- 여행 경비를 넘지 않으며 최대 만족도를 갖도록 선택하려면 어떤 코스가 좋을까?
- 여행경비는 70만원이 있으며, 이동 경로는 고려하지 않는다.
```

​	도시 하나만 / 두 개를/ 세 개를/ 네 개를/ ... / 갔을 경우 모든 경우를 봐야하기 때문에

​	`6C1` + `6C2` + … + `6C6` = 2^6 - 1 *(공집합 제외)*  의 경우를 봐야하는 거죠.



​	이럴 경우 시간 복잡도는 O(2^n) 이 될겁니다.



