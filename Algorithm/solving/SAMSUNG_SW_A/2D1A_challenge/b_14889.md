# 기존 코드
~~~python
'''축구를 하기 위해서 항상 짝수 N명이 모인다. '''

def score_in_the_team(team):
    score = 0
    comb_lst = list(combinations(team ,2 ))

    for idx, jdx in comb_lst:
        score +=  (S[idx][jdx] + S[jdx][idx])

    return score


from itertools import combinations

N = int(input())

S = [list(map(int, input().split())) for _ in range(N)]

team  = list(combinations(range(N), N//2))
team_set = set(team)

A_team = [people for people in team if 0 in people]
A_team_set = set(A_team)  # 차집합 연산을 위한 형변환

min_diff = float('inf')

for A in A_team_set:
    B = list(set(range(N)) - set(A))

    A_score = score_in_the_team(A)
    B_score = score_in_the_team(B)

    diff = abs(A_score - B_score)

    if diff < min_diff : 
        min_diff = diff

    if diff == 0 : #최적값이라면
        min_diff = 0
        break

print(min_diff)
~~~
<br><br>

# 총평
- (핵심 강점) 중복 팀 비교 제거(0이 포함된 팀만 순회), 팀 내부 시너지 합을 함수로 분리한 구조는 명확합니다.
- (핵심 개선 필요) 매 반복마다 `list(combinations(...))`와 `set(...)` 생성 등 불필요한 객체 생성이 많아 시간/메모리 비효율이 있습니다. 전역 변수 사용, 네이밍/타입힌트 부족으로 가독성도 떨어집니다.
- (주요 병목/리스크) `score_in_the_team`에서 매번 리스트로 조합을 물질화, 메인 루프에서 `set(range(N)) - set(A)`를 반복적으로 생성하는 부분이 병목입니다.
<br><br>

# 복잡도 및 병목
- 시간 복잡도:
  - 팀 선택 루프: `O(C(N-1, N/2-1))`
  - 각 팀 점수 계산: 팀 내 쌍 개수 `C(N/2, 2)`에 대해 합산 → `O(C(N/2, 2))`
  - 총합: `O(C(N-1, N/2-1) * C(N/2, 2))`
- 공간 복잡도:
  - 입력 행렬 `S`: `O(N^2)`
  - 불필요한 `list(combinations(...))`, 반복적 `set(...)` 생성으로 추가 임시 객체가 다수 발생
- 병목 지점:
  1) `score_in_the_team`: `comb_lst = list(combinations(team, 2))` (조합을 리스트로 물질화)  
  2) 메인 루프: `B = list(set(range(N)) - set(A))` (매 반복마다 두 개의 `set` 생성)  
  3) 전역 `S` 의존과 중복되는 합산(`S[i][j] + S[j][i]`) 계산 반복
<br><br>

# 보완점
## 1. 조합 리스트 물질화 제거 및 합산 사전계산  [중요도: High] [효과: 성능]
- `combinations`는 이터레이터이므로 리스트로 변환하지 말고 바로 순회합니다.
- `S[i][j] + S[j][i]`는 대칭적이므로 루프 외부에서 `pair_sum[i][j] (i<j)`로 미리 계산해두면 합산 연산량이 줄어듭니다.
~~~python
# 전
comb_lst = list(combinations(team, 2))
for a, b in comb_lst:
    score += (S[a][b] + S[b][a])

# 후
for a, b in combinations(team, 2):
    score += pair_sum[min(a,b)][max(a,b)]
~~~
<br><br><br>

## 2. 보편집(precompute)으로 보조 집합/시퀀스 재사용  [중요도: Med] [효과: 성능/가독]
- `all_people = set(range(N))`을 한 번만 만들고, 매 반복에서는 `all_people - setA`로 보완합니다.
- 0을 포함하는 팀만 만들려면 아예 `combinations(range(1, N), N//2 - 1)`로 생성한 뒤 `{0} ∪ 부분집합`으로 팀 `A`를 구성하면 필터링과 중복 컨테이너가 사라집니다.
~~~python
# 전
team = list(combinations(range(N), N//2))
A_team = [people for people in team if 0 in people]

# 후
for subset in combinations(range(1, N), N//2 - 1):
    A = (0,) + subset
~~~
<br><br><br>

## 3. 전역 상태 제거 및 타입힌트/네이밍/도큐스트링 보강  [중요도: Med] [효과: 가독/유지보수]
- `S`를 전역으로 참조하지 말고 함수 인자로 전달합니다.
- 명확한 함수/변수명, 타입힌트, 도큐스트링을 추가합니다.
~~~python
def team_score(team: Iterable[int], pair_sum: List[List[int]]) -> int:
    """팀 내 모든 (i,j) 쌍에 대한 시너지 합을 반환한다."""
    total = 0
    for i, j in combinations(team, 2):
        a, b = (i, j) if i < j else (j, i)
        total += pair_sum[a][b]
    return total
~~~
<br><br><br>

## 4. 조기 종료(Early Exit)와 최소화된 임시객체  [중요도: Low] [효과: 성능]
- `diff == 0`인 경우 즉시 반환.
- `B`를 리스트로 만들 필요 없이 튜플/리스트 어느 쪽이든 `team_score`가 이터러블만 받으면 됩니다.
- `set(A)`도 반복 사용하므로 한 번만 생성합니다.
~~~python
setA = set(A)
B = tuple(p for p in range(N) if p not in setA)
~~~
<br><br><br>

## 5. 입력/출력 경계 명확화  [중요도: Low] [효과: 안정성/가독]
- `if __name__ == "__main__":` 가드와 간단 예시/주석을 추가합니다.
<br><br><br>

# 최종 코드 예시
~~~python
from itertools import combinations
from typing import Iterable, List

def build_pair_sum(S: List[List[int]]) -> List[List[int]]:
    """
    S[i][j] + S[j][i]를 미리 합산한 대칭 상삼각 행렬(pair_sum)을 만든다.
    pair_sum[i][j]는 i<j에서만 의미가 있다.
    """
    n = len(S)
    pair_sum = [[0]*n for _ in range(n)]
    for i in range(n):
        for j in range(i+1, n):
            pair_sum[i][j] = S[i][j] + S[j][i]
    return pair_sum

def team_score(team: Iterable[int], pair_sum: List[List[int]]) -> int:
    """
    팀 내 모든 2원소 조합의 시너지 합을 반환한다.
    team: 선수 인덱스 이터러블
    pair_sum: 미리 계산된 S[i][j] + S[j][i] 상삼각 행렬
    """
    total = 0
    for a, b in combinations(team, 2):
        i, j = (a, b) if a < b else (b, a)
        total += pair_sum[i][j]
    return total

def min_team_diff(S: List[List[int]]) -> int:
    """
    N은 짝수. N명을 두 팀(N/2명씩)으로 나눌 때
    두 팀 시너지 합의 차이의 최솟값을 반환한다.
    중복 제거를 위해 0번 선수를 항상 A팀에 포함시킨다.
    """
    n = len(S)
    half = n // 2
    pair_sum = build_pair_sum(S)

    # 0번 선수를 포함하는 A팀만 생성: 나머지에서 (half-1)명 선택
    min_diff = float("inf")
    all_people_range = range(n)

    for subset in combinations(range(1, n), half - 1):
        A = (0,) + subset
        setA = set(A)

        # A의 여집합이 B
        B = [p for p in all_people_range if p not in setA]

        diff = abs(team_score(A, pair_sum) - team_score(B, pair_sum))
        if diff < min_diff:
            min_diff = diff
            if min_diff == 0:  # 최적값에 도달 시 조기 종료
                return 0

    return min_diff

if __name__ == "__main__":
    # 입력 형식:
    # N
    # S[0][0] S[0][1] ... S[0][N-1]
    # ...
    # S[N-1][0] ...      S[N-1][N-1]
    #
    # 예시)
    # 4
    # 0 1 2 3
    # 4 0 5 6
    # 7 1 0 2
    # 3 4 5 0
    import sys

    input = sys.stdin.readline
    N = int(input().strip())
    S = [list(map(int, input().split())) for _ in range(N)]

    print(min_team_diff(S))
~~~
